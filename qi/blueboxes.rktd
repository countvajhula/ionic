4704
((3) 0 () 3 ((q lib "qi/main.rkt") (q 7552 . 3) (q lib "qi/probe.rkt")) () (h ! (equal) ((c form c (c (? . 0) q AND)) q (5238 . 2)) ((c form c (c (? . 0) q count)) q (7309 . 2)) ((c form c (c (? . 0) q NOT)) q (5218 . 2)) ((c form c (c (? . 0) q π)) q (4404 . 2)) ((c form c (c (? . 0) q any?)) q (5325 . 2)) ((c form c (c (? . 0) q crossover)) q (5457 . 2)) ((c form c (c (? . 0) q tee)) q (5592 . 2)) ((c form c (c (? . 0) q collect)) q (4972 . 2)) ((c form c (c (? . 0) q define-qi-syntax)) q (7622 . 2)) ((c form c (c (? . 0) q relay*)) q (5544 . 2)) ((c form c (c (? . 0) q -<)) q (5570 . 2)) ((c form c (c (? . 0) q clos)) q (5006 . 2)) ((c form c (c (? . 0) q sep)) q (4914 . 2)) ((c form c (c (? . 0) q all?)) q (5337 . 2)) ((c form c (c (? . 0) q if)) q (5992 . 2)) ((c form c (c (? . 0) q not)) q (5153 . 2)) ((c form c (c (? . 0) q inverter)) q (5362 . 2)) ((c form c (c (? . 0) q all)) q (5053 . 2)) ((c form c (c (? . 0) q 4>)) q (5678 . 2)) ((c form c (c (? . 0) q 9>)) q (5728 . 2)) ((c form c (c (? . 0) q define-qi-syntax-parser)) q (7476 . 2)) ((c form c (c (? . 0) q gate)) q (6510 . 2)) ((c form c (c (? . 0) q one-of?)) q (5025 . 2)) ((c form c (c (? . 0) q loop)) q (6539 . 2)) ((c form c (c (? . 0) q when)) q (6052 . 2)) ((c form c (c (? . 0) q sieve)) q (5919 . 2)) ((c form c (c (? . 0) q define-flow)) q (4634 . 2)) ((c form c (c (? . 0) q ground)) q (5389 . 2)) ((c def c (c (? . 0) q struct:qi-macro)) c (? . 1)) ((c form c (c (? . 0) q fanout)) q (5615 . 2)) ((c form c (c (? . 0) q pass)) q (7033 . 2)) ((c form c (c (? . 0) q group)) q (5853 . 2)) ((c form c (c (? . 0) q ⏚)) q (5378 . 2)) ((c form c (c (? . 0) q none?)) q (5349 . 2)) ((c def c (c (? . 0) q qi-macro-transformer)) c (? . 1)) ((c form c (c (? . 0) q NAND)) q (5290 . 2)) ((c form c (c (? . 2) q readout)) q (7691 . 2)) ((c form c (c (? . 0) q ∥)) q (5268 . 2)) ((c form c (c (? . 0) q loop2)) q (6714 . 2)) ((c form c (c (? . 0) q on)) q (4137 . 2)) ((c form c (c (? . 0) q define-switch)) q (4718 . 5)) ((c form c (c (? . 0) q esc)) q (4987 . 2)) ((c form c (c (? . 0) q △)) q (4903 . 2)) ((c form c (c (? . 0) q switch)) q (4255 . 6)) ((c form c (c (? . 0) q or%)) q (5195 . 2)) ((c form c (c (? . 0) q flow-lambda)) q (4366 . 2)) ((c form c (c (? . 0) q 7>)) q (5708 . 2)) ((c form c (c (? . 0) q select)) q (5738 . 2)) ((c form c (c (? . 0) q apply)) q (7296 . 2)) ((c form c (c (? . 0) q effect)) q (7225 . 2)) ((c form c (c (? . 0) q none)) q (5089 . 2)) ((c form c (c (? . 0) q any)) q (5071 . 2)) ((c form c (c (? . 0) q relay)) q (5496 . 2)) ((c form c (c (? . 0) q 1>)) q (5648 . 2)) ((c form c (c (? . 0) q rectify)) q (7335 . 2)) ((c form c (c (? . 0) q unless)) q (6097 . 2)) ((c form c (c (? . 0) q 8>)) q (5718 . 2)) ((c def c (c (? . 0) q qi-macro?)) c (? . 1)) ((c form c (c (? . 0) q X)) q (5448 . 2)) ((c form c (c (? . 0) q switch-lambda)) q (4433 . 5)) ((c form c (c (? . 0) q try)) q (6912 . 2)) ((c form c (c (? . 0) q and%)) q (5171 . 2)) ((c form c (c (? . 0) q <<)) q (7074 . 2)) ((c form c (c (? . 0) q ☯)) q (0 . 124)) ((c form c (c (? . 0) q define-qi-syntax-rule)) q (7385 . 3)) ((c form c (c (? . 2) q define-probed-flow)) q (7729 . 2)) ((c form c (c (? . 0) q ==*)) q (5521 . 2)) ((c form c (c (? . 0) q define-qi-foreign-syntaxes)) q (4823 . 2)) ((c form c (c (? . 0) q live?)) q (7322 . 2)) ((c def c (c (? . 0) q qi-macro)) c (? . 1)) ((c form c (c (? . 0) q feedback)) q (6766 . 2)) ((c form c (c (? . 0) q or)) q (5131 . 2)) ((c form c (c (? . 0) q qi:*)) q (7360 . 2)) ((c form c (c (? . 0) q block)) q (5766 . 2)) ((c form c (c (? . 0) q ~>>)) q (4213 . 2)) ((c form c (c (? . 0) q 3>)) q (5668 . 2)) ((c form c (c (? . 0) q OR)) q (5258 . 2)) ((c form c (c (? . 0) q flow)) q (4112 . 2)) ((c form c (c (? . 0) q bundle)) q (5793 . 2)) ((c form c (c (? . 0) q >>)) q (7118 . 2)) ((c form c (c (? . 0) q NOR)) q (5279 . 2)) ((c form c (c (? . 2) q qi:probe)) q (7706 . 2)) ((c form c (c (? . 2) q probe)) q (7671 . 2)) ((c form c (c (? . 0) q and)) q (5108 . 2)) ((c form c (c (? . 0) q _)) q (4870 . 2)) ((c form c (c (? . 0) q amp)) q (7004 . 2)) ((c form c (c (? . 0) q &)) q (5249 . 2)) ((c form c (c (? . 0) q ==)) q (5474 . 2)) ((c form c (c (? . 0) q XOR)) q (5302 . 2)) ((c form c (c (? . 0) q 6>)) q (5698 . 2)) ((c form c (c (? . 0) q ▽)) q (4961 . 2)) ((c form c (c (? . 0) q ~>)) q (4172 . 2)) ((c form c (c (? . 0) q λ01)) q (4538 . 5)) ((c form c (c (? . 0) q ><)) q (6977 . 2)) ((c form c (c (? . 0) q 5>)) q (5688 . 2)) ((c form c (c (? . 0) q ε)) q (7162 . 2)) ((c form c (c (? . 0) q !)) q (5229 . 2)) ((c form c (c (? . 0) q XNOR)) q (5313 . 2)) ((c form c (c (? . 0) q gen)) q (4879 . 2)) ((c form c (c (? . 0) q 2>)) q (5658 . 2))))
syntax
(☯ flow-expr)
 
  flow-expr = _
            | (gen expr ...)
            | △
            | sep
            | ▽
            | collect
            | (esc expr)
            | (clos flow-expr)
            | (one-of? expr ...)
            | (all flow-expr)
            | (any flow-expr)
            | (none flow-expr)
            | (and flow-expr ...)
            | (or flow-expr ...)
            | (not flow-expr)
            | (and% flow-expr ...)
            | (or% flow-expr ...)
            | NOT
            | !
            | AND
            | &
            | OR
            | ∥
            | NOR
            | NAND
            | XOR
            | XNOR
            | any?
            | all?
            | none?
            | inverter
            | ⏚
            | ground
            | (~> flow-expr ...)
            | (thread flow-expr ...)
            | (~>> flow-expr ...)
            | (thread-right flow-expr ...)
            | X
            | crossover
            | (== flow-expr ...)
            | (relay flow-expr ...)
            | (==* flow-expr ...)
            | (relay* flow-expr ...)
            | (-< flow-expr ...)
            | (tee flow-expr ...)
            | fanout
            | (fanout number)
            | feedback
            | (feedback number flow-expr)
            | (feedback number (then flow-expr) flow-expr)
            | (feedback (while flow-expr) flow-expr)
            | (feedback (while flow-expr) (then flow-expr) flow-expr)
            | count
            | 1>
            | 2>
            | 3>
            | 4>
            | 5>
            | 6>
            | 7>
            | 8>
            | 9>
            | (select index ...)
            | (block index ...)
            | (bundle (index ...) flow-expr flow-expr)
            | (group number flow-expr flow-expr)
            | sieve
            | (sieve flow-expr flow-expr flow-expr)
            | (if flow-expr flow-expr)
            | (if flow-expr flow-expr flow-expr)
            | (when flow-expr flow-expr)
            | (unless flow-expr flow-expr)
            | switch
            | (switch switch-expr ...)
            | (switch (% flow-expr) switch-expr ...)
            | (switch (divert flow-expr) switch-expr ...)
            | (gate flow-expr)
            | ><
            | (>< flow-expr)
            | amp
            | (amp flow-expr)
            | pass
            | (pass flow-expr)
            | <<
            | (<< flow-expr)
            | (<< flow-expr flow-expr)
            | >>
            | (>> flow-expr)
            | (>> flow-expr flow-expr)
            | (loop flow-expr)
            | (loop flow-expr flow-expr)
            | (loop flow-expr flow-expr flow-expr)
            | (loop flow-expr flow-expr flow-expr flow-expr)
            | (loop2 flow-expr flow-expr flow-expr)
            | (ε flow-expr flow-expr)
            | (effect flow-expr flow-expr)
            | apply
            | literal
            | (quote value)
            | (quasiquote value)
            | (quote-syntax value)
            | (syntax value)
            | (qi:* expr ...)
            | (expr expr ... __ expr ...)
            | (expr expr ... _ expr ...)
            | (expr expr ...)
            | expr
               
       expr = a-racket-expression
               
      index = exact-positive-integer?
               
     number = exact-nonnegative-integer?
               
switch-expr = [flow-expr flow-expr]
            | [flow-expr (=> flow-expr)]
            | [else flow-expr]
               
    literal = a-racket-literal
               
      value = a-racket-value
syntax
(flow flow-expr)
syntax
(on (arg ...) flow-expr)
syntax
(~> (args ...) flow-expr ...)
syntax
(~>> (args ...) flow-expr ...)
syntax
(switch (arg ...)
  maybe-divert-clause
  [predicate consequent]
  ...
  [else consequent])
syntax
(flow-lambda args body ...)
syntax
(π args body ...)
syntax
(switch-lambda (args ...)
  [predicate consequent ...]
  ...
  [else consequent ...])
syntax
(λ01 (args ...)
  [predicate consequent ...]
  ...
  [else consequent ...])
syntax
(define-flow name body ...)
syntax
(define-flow (name args) body ...)
syntax
(define-switch (args ...)
  [predicate consequent ...]
  ...
  [else consequent ...])
syntax
(define-qi-foreign-syntaxes form ...)
syntax
_
syntax
(gen expr ...)
syntax
△
syntax
sep
syntax
(△ flo)
syntax
(sep flo)
syntax
▽
syntax
collect
syntax
(esc expr)
syntax
(clos flo)
syntax
(one-of? expr ...)
syntax
(all flo)
syntax
(any flo)
syntax
(none flo)
syntax
(and flo ...)
syntax
(or flo ...)
syntax
(not flo)
syntax
(and% flo ...)
syntax
(or% flo ...)
syntax
NOT
syntax
!
syntax
AND
syntax
&
syntax
OR
syntax
∥
syntax
NOR
syntax
NAND
syntax
XOR
syntax
XNOR
syntax
any?
syntax
all?
syntax
none?
syntax
inverter
syntax
⏚
syntax
ground
syntax
(~> flo ...)
syntax
(~>> flo ...)
syntax
X
syntax
crossover
syntax
(== flo ...)
syntax
(relay flo ...)
syntax
(==* flo ...)
syntax
(relay* flo ...)
syntax
(-< flo ...)
syntax
(tee flo ...)
syntax
fanout
syntax
(fanout N)
syntax
1>
syntax
2>
syntax
3>
syntax
4>
syntax
5>
syntax
6>
syntax
7>
syntax
8>
syntax
9>
syntax
(select index ...)
syntax
(block index ...)
syntax
(bundle (index ...) selection-flo remainder-flo)
syntax
group
syntax
(group number selection-flo remainder-flo)
syntax
sieve
syntax
(sieve condition-flo selection-flo remainder-flo)
syntax
(if condition-flo consequent-flo alternative-flo)
syntax
(when condition-flo consequent-flo)
syntax
(unless condition-flo alternative-flo)
syntax
(switch maybe-divert-expr switch-expr ...)
 
maybe-divert-expr = (divert condition-gate-flow consequent-gate-flow)
                  | (% condition-gate-flow consequent-gate-flow)
                     
      switch-expr = [flow-expr flow-expr]
                  | [flow-expr (=> flow-expr)]
                  | [else flow-expr]
syntax
(gate condition-flo)
syntax
(loop condition-flo map-flo combine-flo return-flo)
syntax
(loop condition-flo map-flo combine-flo)
syntax
(loop condition-flo map-flo)
syntax
(loop map-flo)
syntax
(loop2 condition-flo map-flo combine-flo)
syntax
feedback
syntax
(feedback N flo)
syntax
(feedback N (then then-flo) flo)
syntax
(feedback (while cond-flo) (then then-flo) flo)
syntax
(try flo [error-predicate-flo error-handler-flo] ...)
syntax
><
syntax
(>< flo)
syntax
amp
syntax
(amp flo)
syntax
pass
syntax
(pass condition-flo)
syntax
(<< flo init-flo)
syntax
(<< flo)
syntax
(>> flo init-flo)
syntax
(>> flo)
syntax
(ε side-effect-flo flo)
syntax
(ε side-effect-flo)
syntax
(effect side-effect-flo flo)
syntax
(effect side-effect-flo)
syntax
apply
syntax
count
syntax
live?
syntax
(rectify v ...)
syntax
(qi:* expr ...)
syntax
(define-qi-syntax-rule (macro-id . pattern) pattern-directive ...
  template)
syntax
(define-qi-syntax-parser macro-id parse-option ... clause ...+)
struct
(struct qi-macro (transformer))
  transformer : procedure?
syntax
(define-qi-syntax macro-id transformer)
syntax
(probe flo)
syntax
readout
syntax
(qi:probe flo)
syntax
(define-probed-flow name body ...)
syntax
(define-probed-flow (name arg ...) body ...)
